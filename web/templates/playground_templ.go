// Code generated by templ - DO NOT EDIT.

// templ: version: v0.3.898
package templates

//lint:file-ignore SA4006 This context is only used if a nested component is present.

import "github.com/a-h/templ"
import templruntime "github.com/a-h/templ/runtime"

func playground() templ.Component {
	return templruntime.GeneratedTemplate(func(templ_7745c5c3_Input templruntime.GeneratedComponentInput) (templ_7745c5c3_Err error) {
		templ_7745c5c3_W, ctx := templ_7745c5c3_Input.Writer, templ_7745c5c3_Input.Context
		if templ_7745c5c3_CtxErr := ctx.Err(); templ_7745c5c3_CtxErr != nil {
			return templ_7745c5c3_CtxErr
		}
		templ_7745c5c3_Buffer, templ_7745c5c3_IsBuffer := templruntime.GetBuffer(templ_7745c5c3_W)
		if !templ_7745c5c3_IsBuffer {
			defer func() {
				templ_7745c5c3_BufErr := templruntime.ReleaseBuffer(templ_7745c5c3_Buffer)
				if templ_7745c5c3_Err == nil {
					templ_7745c5c3_Err = templ_7745c5c3_BufErr
				}
			}()
		}
		ctx = templ.InitializeContext(ctx)
		templ_7745c5c3_Var1 := templ.GetChildren(ctx)
		if templ_7745c5c3_Var1 == nil {
			templ_7745c5c3_Var1 = templ.NopComponent
		}
		ctx = templ.ClearChildren(ctx)
		templ_7745c5c3_Err = templruntime.WriteString(templ_7745c5c3_Buffer, 1, "<br><div class=\"dropdown\"><button class=\"btn btn-secondary dropdown-toggle ms-3\" type=\"button\" data-bs-toggle=\"dropdown\" aria-expanded=\"false\">Layout</button><ul class=\"dropdown-menu\"><li><a class=\"dropdown-item\" href=\"#\">Hands Down Promethium</a></li><li><a class=\"dropdown-item\" href=\"#\">Colemak-DH</a></li><li><a class=\"dropdown-item\" href=\"#\">Dvorak</a></li></ul></div><div class=\"container-fluid vh-100 d-flex justify-content-center align-items-center\"><div class=\"row\"><div class=\"col-12 d-flex flex-column align-items-center\"><div id=\"textDisplay\" class=\"mb-3 text-truncate text-nowrap overflow-hidden d-block\" style=\"width: 500px; min-width:500px; height: 50px;\"><span id=\"pastText\" style=\"color: #6c757d;\"></span> <span id=\"currentText\" style=\"font-weight: bold;\"></span> <span id=\"futureText\"></span></div><input type=\"text\" style=\"width:300px; min-width:300px;\" id=\"typingInput\" placeholder=\"Start typing...\"><br><p id=\"wpmDisplay\">WPM: 0</p><img style=\"padding-top: 7rem;\" src=\"/assets/hands-down-promethium.webp\"></div></div></div><script>\n    class FixedQueue {\n        constructor(limit) {\n            this.limit = limit;\n            this.queue = [];\n        }\n\n        add(item) {\n            if (this.queue.length >= this.limit) {\n                this.queue.shift();  // remove the oldest (first) item\n            }\n            this.queue.push(item); // add the new item\n        }\n\n        get items() {\n            return this.queue;\n        }\n    }\n\n    const qwertyToHDP = {\n        'KeyQ': 'f', 'KeyW': 'p', 'KeyE': 'd', 'KeyR': 'l', 'KeyT': 'x', 'KeyY': ';', 'KeyU': 'u', 'KeyI': 'o', 'KeyO': 'y', 'KeyP': 'b', 'Backslash': 'z',\n        'KeyA': 's', 'KeyS': 'n', 'KeyD': 't', 'KeyF': 'h', 'KeyG': 'k', 'KeyH': ',', 'KeyJ': 'a', 'KeyK': 'e', 'KeyL': 'i', 'Semicolon': 'c', 'Quote': 'q',\n        'ShiftLeft': '\\\\', 'KeyZ': 'v', 'KeyX': 'w', 'KeyC': 'g', 'KeyV': 'm', 'KeyB': 'j', 'KeyN': '-', 'KeyM': '.', 'Comma': '\\'', 'Period': '=', 'Slash': '/',\n        'ArrowRight': 'r'\n    };\n\n    const inputField = document.getElementById('typingInput');\n\n    let shiftDown = false;\n    let shiftTapTimer = null;\n    let shiftWasHeld = false;\n    let startTime = null;\n    let endTime = null;\n    let hasStarted = false;\n    let charCount = 0;\n\n\n    // const sampleText = \"sink think neck stack stink sneak snick snack knack tick thick niche ant east seat site sake shin skin hint sent ask skate snake taken knits skein aches chest cheat teach kite knit sane sect secta ink ski ace teens sheet heat satin hasten sake sink stake case sheik keen\";\n    const sampleText = \"The quick brown fox jumps over a lazy dog while vexed wizards glaze bright jugs, packing five dozen liquor bottles quietly before Jack amazed them with extra flying zebras near icy hills.\" \n    const words = shuffleArray([...sampleText.split(' ')]);\n\n    inputField.addEventListener(\"focus\", () => {\n        inputField.addEventListener(\"keydown\", handleKeyDown);\n        inputField.addEventListener(\"keyup\", handleKeyUp);\n    });\n\n    function wpmCounter() {\n        if (!hasStarted) {\n            startTime = new Date();\n            hasStarted = true;\n        }\n\n        if (charCount >= 10) { // arbitrary threshold to calculate\n            endTime = new Date();\n\n            const timeInMinutes = (endTime - startTime) / 1000 / 60;\n            const wpm = (charCount / 5) / timeInMinutes;\n            const wpmDisplay = document.getElementById('wpmDisplay');\n            wpmDisplay.textContent = `WPM: ${wpm.toFixed(2)}`;\n        }\n    }\n\n    function shuffleArray(array) {\n        for (let i = array.length - 1; i > 0; i--) {\n            const j = Math.floor(Math.random() * (i + 1));\n            [array[i], array[j]] = [array[j], array[i]]; // Swap\n        }\n        return array;\n    }\n\n    function handleKeyDown(e) {\n        wpmCounter();//start counter \n        if (e.ctrlKey || e.metaKey || e.altKey) return;\n\n        // Detect shift key down\n        if (e.code === \"ShiftLeft\" || e.code === \"ShiftRight\") {\n            if (!shiftDown) {\n                shiftDown = true;\n                shiftWasHeld = false;\n                shiftTapTimer = setTimeout(() => {\n                    shiftWasHeld = true;\n                }, 150); // holding longer than 150ms is \"hold\"\n            }\n            return;\n        }\n\n        if (qwertyToHDP[e.code]) {\n            e.preventDefault();\n            let char = qwertyToHDP[e.code];\n            if (shiftDown && shiftWasHeld && char.length === 1) {\n                char = char.toUpperCase();\n            }\n            charCount++;\n            inputField.value += char;\n        }\n    }\n    function handleKeyUp(e) {\n        // Shift released\n        if (e.code === \"ShiftLeft\" || e.code === \"ShiftRight\") {\n            clearTimeout(shiftTapTimer);\n\n            if (!shiftWasHeld) {\n                inputField.value += qwertyToHDP[e.code]\n            }\n\n            shiftDown = false;\n            shiftWasHeld = false;\n            return;\n        }\n    }\n\n    document.addEventListener('DOMContentLoaded', function () {\n        const inputField = document.getElementById('typingInput');\n        const pastTextElement = document.getElementById('pastText');\n        const currentTextElement = document.getElementById('currentText');\n        const futureTextElement = document.getElementById('futureText');\n        let placeholderRemoved = false;\n\n        // Sample text - you can replace this with your dictionary later\n\n        const visibleWordCount = 10;\n        let currentWordIndex = 0;\n\n        //list of previous words.  setting it to 3 here, can probably be editable. \n        const prevWords = new FixedQueue(6);\n\n        // Initial display setup\n        updateTextDisplay();\n\n        function updateTextDisplay() {\n            // Past text (typed words)\n            // pastTextElement.textContent = words.slice(currentWordIndex - 2, currentWordIndex).join(' ') + ' ';\n            pastTextElement.textContent = prevWords.queue.join(' ') || '';\n\n            // Current word (word to type now)\n            let cw = words[currentWordIndex]\n            currentTextElement.textContent = cw || '';\n            prevWords.add(cw);\n\n            // Future text (upcoming words)\n            const futureWords = words.slice(currentWordIndex + 1);\n            futureTextElement.textContent = ' ' + futureWords.join(' ');\n            // futureTextElement.textContent = sampleText\n        }\n\n        inputField.addEventListener('keydown', function (event) {\n            // Check if the pressed key is a space (keyCode 32)\n            if (event.key === ' ' || event.keyCode === 32) {\n                event.preventDefault(); // Prevent the default space behavior\n\n                // Check if the typed word matches the current word\n                const typedWord = this.value.trim();\n                const currentWord = words[currentWordIndex];\n\n                if (typedWord === currentWord) {\n                    // Move to next word\n                    currentWordIndex++;\n                    updateTextDisplay();\n                }\n\n                this.value = ''; // Clear the input field\n\n                // Remove placeholder after first space if not already removed\n                if (!placeholderRemoved) {\n                    this.placeholder = '';\n                    placeholderRemoved = true;\n                }\n            }\n        });\n    });\n</script>")
		if templ_7745c5c3_Err != nil {
			return templ_7745c5c3_Err
		}
		return nil
	})
}

func Playground() templ.Component {
	return templruntime.GeneratedTemplate(func(templ_7745c5c3_Input templruntime.GeneratedComponentInput) (templ_7745c5c3_Err error) {
		templ_7745c5c3_W, ctx := templ_7745c5c3_Input.Writer, templ_7745c5c3_Input.Context
		if templ_7745c5c3_CtxErr := ctx.Err(); templ_7745c5c3_CtxErr != nil {
			return templ_7745c5c3_CtxErr
		}
		templ_7745c5c3_Buffer, templ_7745c5c3_IsBuffer := templruntime.GetBuffer(templ_7745c5c3_W)
		if !templ_7745c5c3_IsBuffer {
			defer func() {
				templ_7745c5c3_BufErr := templruntime.ReleaseBuffer(templ_7745c5c3_Buffer)
				if templ_7745c5c3_Err == nil {
					templ_7745c5c3_Err = templ_7745c5c3_BufErr
				}
			}()
		}
		ctx = templ.InitializeContext(ctx)
		templ_7745c5c3_Var2 := templ.GetChildren(ctx)
		if templ_7745c5c3_Var2 == nil {
			templ_7745c5c3_Var2 = templ.NopComponent
		}
		ctx = templ.ClearChildren(ctx)
		templ_7745c5c3_Err = Base(playground()).Render(ctx, templ_7745c5c3_Buffer)
		if templ_7745c5c3_Err != nil {
			return templ_7745c5c3_Err
		}
		return nil
	})
}

var _ = templruntime.GeneratedTemplate
